//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreData;
use crate::Foundation;

extern_static!(NSSQLiteStoreType: &'static Foundation::NSString);

extern_static!(NSXMLStoreType: &'static Foundation::NSString);

extern_static!(NSBinaryStoreType: &'static Foundation::NSString);

extern_static!(NSInMemoryStoreType: &'static Foundation::NSString);

extern_static!(NSStoreTypeKey: &'static Foundation::NSString);

extern_static!(NSStoreUUIDKey: &'static Foundation::NSString);

extern_static!(
    NSPersistentStoreCoordinatorStoresWillChangeNotification: &'static Foundation::NSString
);

extern_static!(
    NSPersistentStoreCoordinatorStoresDidChangeNotification: &'static Foundation::NSString
);

extern_static!(
    NSPersistentStoreCoordinatorWillRemoveStoreNotification: &'static Foundation::NSString
);

extern_static!(NSAddedPersistentStoresKey: &'static Foundation::NSString);

extern_static!(NSRemovedPersistentStoresKey: &'static Foundation::NSString);

extern_static!(NSUUIDChangedPersistentStoresKey: &'static Foundation::NSString);

extern_static!(NSReadOnlyPersistentStoreOption: &'static Foundation::NSString);

extern_static!(NSValidateXMLStoreOption: &'static Foundation::NSString);

extern_static!(NSPersistentStoreTimeoutOption: &'static Foundation::NSString);

extern_static!(NSSQLitePragmasOption: &'static Foundation::NSString);

extern_static!(NSSQLiteAnalyzeOption: &'static Foundation::NSString);

extern_static!(NSSQLiteManualVacuumOption: &'static Foundation::NSString);

extern_static!(NSIgnorePersistentStoreVersioningOption: &'static Foundation::NSString);

extern_static!(NSMigratePersistentStoresAutomaticallyOption: &'static Foundation::NSString);

extern_static!(NSInferMappingModelAutomaticallyOption: &'static Foundation::NSString);

extern_static!(NSStoreModelVersionHashesKey: &'static Foundation::NSString);

extern_static!(NSStoreModelVersionIdentifiersKey: &'static Foundation::NSString);

extern_static!(NSPersistentStoreOSCompatibility: &'static Foundation::NSString);

extern_static!(NSPersistentStoreConnectionPoolMaxSizeKey: &'static Foundation::NSString);

extern_static!(NSCoreDataCoreSpotlightExporter: &'static Foundation::NSString);

extern_static!(NSXMLExternalRecordType: &'static Foundation::NSString);

extern_static!(NSBinaryExternalRecordType: &'static Foundation::NSString);

extern_static!(NSExternalRecordsFileFormatOption: &'static Foundation::NSString);

extern_static!(NSExternalRecordsDirectoryOption: &'static Foundation::NSString);

extern_static!(NSExternalRecordExtensionOption: &'static Foundation::NSString);

extern_static!(NSEntityNameInPathKey: &'static Foundation::NSString);

extern_static!(NSStoreUUIDInPathKey: &'static Foundation::NSString);

extern_static!(NSStorePathKey: &'static Foundation::NSString);

extern_static!(NSModelPathKey: &'static Foundation::NSString);

extern_static!(NSObjectURIKey: &'static Foundation::NSString);

extern_static!(NSPersistentStoreForceDestroyOption: &'static Foundation::NSString);

extern_static!(NSPersistentStoreFileProtectionKey: &'static Foundation::NSString);

extern_static!(NSPersistentHistoryTrackingKey: &'static Foundation::NSString);

extern_static!(NSBinaryStoreSecureDecodingClasses: &'static Foundation::NSString);

extern_static!(NSBinaryStoreInsecureDecodingCompatibilityOption: &'static Foundation::NSString);

extern_static!(
    NSPersistentStoreRemoteChangeNotificationPostOptionKey: &'static Foundation::NSString
);

extern_static!(NSPersistentStoreRemoteChangeNotification: &'static Foundation::NSString);

extern_static!(NSPersistentStoreURLKey: &'static Foundation::NSString);

extern_static!(NSPersistentHistoryTokenKey: &'static Foundation::NSString);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPersistentStoreCoordinator;

    unsafe impl ClassType for NSPersistentStoreCoordinator {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
    unsafe impl NSPersistentStoreCoordinator {
        #[cfg(feature = "CoreData_NSManagedObjectModel")]
        #[method_id(@__retain_semantics Init initWithManagedObjectModel:)]
        pub unsafe fn initWithManagedObjectModel(
            this: Option<Allocated<Self>>,
            model: &CoreData::NSManagedObjectModel,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "CoreData_NSManagedObjectModel")]
        #[method_id(@__retain_semantics Other managedObjectModel)]
        pub unsafe fn managedObjectModel(&self) -> Id<CoreData::NSManagedObjectModel, Shared>;

        #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other persistentStores)]
        pub unsafe fn persistentStores(
            &self,
        ) -> Id<Foundation::NSArray<CoreData::NSPersistentStore>, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&Foundation::NSString>);

        #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other persistentStoreForURL:)]
        pub unsafe fn persistentStoreForURL(
            &self,
            URL: &Foundation::NSURL,
        ) -> Option<Id<CoreData::NSPersistentStore, Shared>>;

        #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForPersistentStore:)]
        pub unsafe fn URLForPersistentStore(
            &self,
            store: &CoreData::NSPersistentStore,
        ) -> Id<Foundation::NSURL, Shared>;

        #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
        #[method(setURL:forPersistentStore:)]
        pub unsafe fn setURL_forPersistentStore(
            &self,
            url: &Foundation::NSURL,
            store: &CoreData::NSPersistentStore,
        ) -> bool;

        #[cfg(all(
            feature = "CoreData_NSPersistentStore",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other addPersistentStoreWithType:configuration:URL:options:error:_)]
        pub unsafe fn addPersistentStoreWithType_configuration_URL_options_error(
            &self,
            storeType: &Foundation::NSString,
            configuration: Option<&Foundation::NSString>,
            storeURL: Option<&Foundation::NSURL>,
            options: Option<&Foundation::NSDictionary>,
        ) -> Result<Id<CoreData::NSPersistentStore, Shared>, Id<NSError, Shared>>;

        #[cfg(all(
            feature = "CoreData_NSPersistentStoreDescription",
            feature = "Foundation_NSError"
        ))]
        #[method(addPersistentStoreWithDescription:completionHandler:)]
        pub unsafe fn addPersistentStoreWithDescription_completionHandler(
            &self,
            storeDescription: &CoreData::NSPersistentStoreDescription,
            block: &Block<
                (
                    NonNull<CoreData::NSPersistentStoreDescription>,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        );

        #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSError"))]
        #[method(removePersistentStore:error:_)]
        pub unsafe fn removePersistentStore_error(
            &self,
            store: &CoreData::NSPersistentStore,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(all(
            feature = "CoreData_NSPersistentStore",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method(setMetadata:forPersistentStore:)]
        pub unsafe fn setMetadata_forPersistentStore(
            &self,
            metadata: Option<&Foundation::NSDictionary<Foundation::NSString, Object>>,
            store: &CoreData::NSPersistentStore,
        );

        #[cfg(all(
            feature = "CoreData_NSPersistentStore",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other metadataForPersistentStore:)]
        pub unsafe fn metadataForPersistentStore(
            &self,
            store: &CoreData::NSPersistentStore,
        ) -> Id<Foundation::NSDictionary<Foundation::NSString, Object>, Shared>;

        #[cfg(all(feature = "CoreData_NSManagedObjectID", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other managedObjectIDForURIRepresentation:)]
        pub unsafe fn managedObjectIDForURIRepresentation(
            &self,
            url: &Foundation::NSURL,
        ) -> Option<Id<CoreData::NSManagedObjectID, Shared>>;

        #[cfg(all(
            feature = "CoreData_NSManagedObjectContext",
            feature = "CoreData_NSPersistentStoreRequest",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other executeRequest:withContext:error:_)]
        pub unsafe fn executeRequest_withContext_error(
            &self,
            request: &CoreData::NSPersistentStoreRequest,
            context: &CoreData::NSManagedObjectContext,
        ) -> Result<Id<Object, Shared>, Id<NSError, Shared>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString",
            feature = "Foundation_NSValue"
        ))]
        #[method_id(@__retain_semantics Other registeredStoreTypes)]
        pub unsafe fn registeredStoreTypes(
        ) -> Id<Foundation::NSDictionary<Foundation::NSString, Foundation::NSValue>, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(registerStoreClass:forStoreType:)]
        pub unsafe fn registerStoreClass_forStoreType(
            storeClass: Option<&Class>,
            storeType: &Foundation::NSString,
        );

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other metadataForPersistentStoreOfType:URL:options:error:_)]
        pub unsafe fn metadataForPersistentStoreOfType_URL_options_error(
            storeType: &Foundation::NSString,
            url: &Foundation::NSURL,
            options: Option<&Foundation::NSDictionary>,
        ) -> Result<
            Id<Foundation::NSDictionary<Foundation::NSString, Object>, Shared>,
            Id<NSError, Shared>,
        >;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(setMetadata:forPersistentStoreOfType:URL:options:error:_)]
        pub unsafe fn setMetadata_forPersistentStoreOfType_URL_options_error(
            metadata: Option<&Foundation::NSDictionary<Foundation::NSString, Object>>,
            storeType: &Foundation::NSString,
            url: &Foundation::NSURL,
            options: Option<&Foundation::NSDictionary>,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other elementsDerivedFromExternalRecordURL:)]
        pub unsafe fn elementsDerivedFromExternalRecordURL(
            fileURL: &Foundation::NSURL,
        ) -> Id<Foundation::NSDictionary, Shared>;

        #[cfg(all(
            feature = "CoreData_NSPersistentStore",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other importStoreWithIdentifier:fromExternalRecordsDirectory:toURL:options:withType:error:_)]
        pub unsafe fn importStoreWithIdentifier_fromExternalRecordsDirectory_toURL_options_withType_error(
            &self,
            storeIdentifier: Option<&Foundation::NSString>,
            externalRecordsURL: &Foundation::NSURL,
            destinationURL: &Foundation::NSURL,
            options: Option<&Foundation::NSDictionary>,
            storeType: &Foundation::NSString,
        ) -> Result<Id<CoreData::NSPersistentStore, Shared>, Id<NSError, Shared>>;

        #[cfg(all(
            feature = "CoreData_NSPersistentStore",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other migratePersistentStore:toURL:options:withType:error:_)]
        pub unsafe fn migratePersistentStore_toURL_options_withType_error(
            &self,
            store: &CoreData::NSPersistentStore,
            URL: &Foundation::NSURL,
            options: Option<&Foundation::NSDictionary>,
            storeType: &Foundation::NSString,
        ) -> Result<Id<CoreData::NSPersistentStore, Shared>, Id<NSError, Shared>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(destroyPersistentStoreAtURL:withType:options:error:_)]
        pub unsafe fn destroyPersistentStoreAtURL_withType_options_error(
            &self,
            url: &Foundation::NSURL,
            storeType: &Foundation::NSString,
            options: Option<&Foundation::NSDictionary>,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:_)]
        pub unsafe fn replacePersistentStoreAtURL_destinationOptions_withPersistentStoreFromURL_sourceOptions_storeType_error(
            &self,
            destinationURL: &Foundation::NSURL,
            destinationOptions: Option<&Foundation::NSDictionary>,
            sourceURL: &Foundation::NSURL,
            sourceOptions: Option<&Foundation::NSDictionary>,
            storeType: &Foundation::NSString,
        ) -> Result<(), Id<NSError, Shared>>;

        #[method(performBlock:)]
        pub unsafe fn performBlock(&self, block: &Block<(), ()>);

        #[method(performBlockAndWait:)]
        pub unsafe fn performBlockAndWait(&self, block: &Block<(), ()>);

        #[cfg(all(
            feature = "CoreData_NSPersistentHistoryToken",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other currentPersistentHistoryTokenFromStores:)]
        pub unsafe fn currentPersistentHistoryTokenFromStores(
            &self,
            stores: Option<&Foundation::NSArray>,
        ) -> Option<Id<CoreData::NSPersistentHistoryToken, Shared>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other metadataForPersistentStoreWithURL:error:_)]
        pub unsafe fn metadataForPersistentStoreWithURL_error(
            url: &Foundation::NSURL,
        ) -> Result<Id<Foundation::NSDictionary, Shared>, Id<NSError, Shared>>;

        #[method(lock)]
        pub unsafe fn lock(&self);

        #[method(unlock)]
        pub unsafe fn unlock(&self);

        #[method(tryLock)]
        pub unsafe fn tryLock(&self) -> bool;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other metadataForPersistentStoreOfType:URL:error:_)]
        pub unsafe fn metadataForPersistentStoreOfType_URL_error(
            storeType: Option<&Foundation::NSString>,
            url: &Foundation::NSURL,
        ) -> Result<
            Id<Foundation::NSDictionary<Foundation::NSString, Object>, Shared>,
            Id<NSError, Shared>,
        >;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(setMetadata:forPersistentStoreOfType:URL:error:_)]
        pub unsafe fn setMetadata_forPersistentStoreOfType_URL_error(
            metadata: Option<&Foundation::NSDictionary<Foundation::NSString, Object>>,
            storeType: Option<&Foundation::NSString>,
            url: &Foundation::NSURL,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(removeUbiquitousContentAndPersistentStoreAtURL:options:error:_)]
        pub unsafe fn removeUbiquitousContentAndPersistentStoreAtURL_options_error(
            storeURL: &Foundation::NSURL,
            options: Option<&Foundation::NSDictionary>,
        ) -> Result<(), Id<NSError, Shared>>;
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSPersistentStoreUbiquitousTransitionType {
        NSPersistentStoreUbiquitousTransitionTypeAccountAdded = 1,
        NSPersistentStoreUbiquitousTransitionTypeAccountRemoved = 2,
        NSPersistentStoreUbiquitousTransitionTypeContentRemoved = 3,
        NSPersistentStoreUbiquitousTransitionTypeInitialImportCompleted = 4,
    }
);

extern_static!(NSPersistentStoreUbiquitousContentNameKey: &'static Foundation::NSString);

extern_static!(NSPersistentStoreUbiquitousContentURLKey: &'static Foundation::NSString);

extern_static!(
    NSPersistentStoreDidImportUbiquitousContentChangesNotification: &'static Foundation::NSString
);

extern_static!(NSPersistentStoreUbiquitousTransitionTypeKey: &'static Foundation::NSString);

extern_static!(NSPersistentStoreUbiquitousPeerTokenOption: &'static Foundation::NSString);

extern_static!(NSPersistentStoreRemoveUbiquitousMetadataOption: &'static Foundation::NSString);

extern_static!(NSPersistentStoreUbiquitousContainerIdentifierKey: &'static Foundation::NSString);

extern_static!(NSPersistentStoreRebuildFromUbiquitousContentOption: &'static Foundation::NSString);
