//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation;

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSFileWrapperReadingOptions {
        NSFileWrapperReadingImmediate = 1 << 0,
        NSFileWrapperReadingWithoutMapping = 1 << 1,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSFileWrapperWritingOptions {
        NSFileWrapperWritingAtomic = 1 << 0,
        NSFileWrapperWritingWithNameUpdating = 1 << 1,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileWrapper;

    unsafe impl ClassType for NSFileWrapper {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSFileWrapper")]
    unsafe impl NSFileWrapper {
        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Init initWithURL:options:error:_)]
        pub unsafe fn initWithURL_options_error(
            this: Option<Allocated<Self>>,
            url: &Foundation::NSURL,
            options: NSFileWrapperReadingOptions,
        ) -> Result<Id<Self, Shared>, Id<NSError, Shared>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Init initDirectoryWithFileWrappers:)]
        pub unsafe fn initDirectoryWithFileWrappers(
            this: Option<Allocated<Self>>,
            childrenByPreferredName: &Foundation::NSDictionary<
                Foundation::NSString,
                Foundation::NSFileWrapper,
            >,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Init initRegularFileWithContents:)]
        pub unsafe fn initRegularFileWithContents(
            this: Option<Allocated<Self>>,
            contents: &Foundation::NSData,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Init initSymbolicLinkWithDestinationURL:)]
        pub unsafe fn initSymbolicLinkWithDestinationURL(
            this: Option<Allocated<Self>>,
            url: &Foundation::NSURL,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Init initWithSerializedRepresentation:)]
        pub unsafe fn initWithSerializedRepresentation(
            this: Option<Allocated<Self>>,
            serializeRepresentation: &Foundation::NSData,
        ) -> Option<Id<Self, Shared>>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Option<Allocated<Self>>,
            inCoder: &Foundation::NSCoder,
        ) -> Option<Id<Self, Shared>>;

        #[method(isDirectory)]
        pub unsafe fn isDirectory(&self) -> bool;

        #[method(isRegularFile)]
        pub unsafe fn isRegularFile(&self) -> bool;

        #[method(isSymbolicLink)]
        pub unsafe fn isSymbolicLink(&self) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other preferredFilename)]
        pub unsafe fn preferredFilename(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPreferredFilename:)]
        pub unsafe fn setPreferredFilename(&self, preferredFilename: Option<&Foundation::NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other filename)]
        pub unsafe fn filename(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setFilename:)]
        pub unsafe fn setFilename(&self, filename: Option<&Foundation::NSString>);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other fileAttributes)]
        pub unsafe fn fileAttributes(
            &self,
        ) -> Id<Foundation::NSDictionary<Foundation::NSString, Object>, Shared>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method(setFileAttributes:)]
        pub unsafe fn setFileAttributes(
            &self,
            fileAttributes: &Foundation::NSDictionary<Foundation::NSString, Object>,
        );

        #[cfg(feature = "Foundation_NSURL")]
        #[method(matchesContentsOfURL:)]
        pub unsafe fn matchesContentsOfURL(&self, url: &Foundation::NSURL) -> bool;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(readFromURL:options:error:_)]
        pub unsafe fn readFromURL_options_error(
            &self,
            url: &Foundation::NSURL,
            options: NSFileWrapperReadingOptions,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(writeToURL:options:originalContentsURL:error:_)]
        pub unsafe fn writeToURL_options_originalContentsURL_error(
            &self,
            url: &Foundation::NSURL,
            options: NSFileWrapperWritingOptions,
            originalContentsURL: Option<&Foundation::NSURL>,
        ) -> Result<(), Id<NSError, Shared>>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other serializedRepresentation)]
        pub unsafe fn serializedRepresentation(&self) -> Option<Id<Foundation::NSData, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other addFileWrapper:)]
        pub unsafe fn addFileWrapper(
            &self,
            child: &Foundation::NSFileWrapper,
        ) -> Id<Foundation::NSString, Shared>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other addRegularFileWithContents:preferredFilename:)]
        pub unsafe fn addRegularFileWithContents_preferredFilename(
            &self,
            data: &Foundation::NSData,
            fileName: &Foundation::NSString,
        ) -> Id<Foundation::NSString, Shared>;

        #[method(removeFileWrapper:)]
        pub unsafe fn removeFileWrapper(&self, child: &Foundation::NSFileWrapper);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other fileWrappers)]
        pub unsafe fn fileWrappers(
            &self,
        ) -> Option<
            Id<Foundation::NSDictionary<Foundation::NSString, Foundation::NSFileWrapper>, Shared>,
        >;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other keyForFileWrapper:)]
        pub unsafe fn keyForFileWrapper(
            &self,
            child: &Foundation::NSFileWrapper,
        ) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other regularFileContents)]
        pub unsafe fn regularFileContents(&self) -> Option<Id<Foundation::NSData, Shared>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other symbolicLinkDestinationURL)]
        pub unsafe fn symbolicLinkDestinationURL(&self) -> Option<Id<Foundation::NSURL, Shared>>;
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "Foundation_NSFileWrapper")]
    unsafe impl NSFileWrapper {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithPath:)]
        pub unsafe fn initWithPath(
            this: Option<Allocated<Self>>,
            path: &Foundation::NSString,
        ) -> Option<Id<Self, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initSymbolicLinkWithDestination:)]
        pub unsafe fn initSymbolicLinkWithDestination(
            this: Option<Allocated<Self>>,
            path: &Foundation::NSString,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(needsToBeUpdatedFromPath:)]
        pub unsafe fn needsToBeUpdatedFromPath(&self, path: &Foundation::NSString) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method(updateFromPath:)]
        pub unsafe fn updateFromPath(&self, path: &Foundation::NSString) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method(writeToFile:atomically:updateFilenames:)]
        pub unsafe fn writeToFile_atomically_updateFilenames(
            &self,
            path: &Foundation::NSString,
            atomicFlag: bool,
            updateFilenamesFlag: bool,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other addFileWithPath:)]
        pub unsafe fn addFileWithPath(
            &self,
            path: &Foundation::NSString,
        ) -> Id<Foundation::NSString, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other addSymbolicLinkWithDestination:preferredFilename:)]
        pub unsafe fn addSymbolicLinkWithDestination_preferredFilename(
            &self,
            path: &Foundation::NSString,
            filename: &Foundation::NSString,
        ) -> Id<Foundation::NSString, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other symbolicLinkDestination)]
        pub unsafe fn symbolicLinkDestination(&self) -> Id<Foundation::NSString, Shared>;
    }
);
