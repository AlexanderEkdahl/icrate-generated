//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSTaskTerminationReason {
        NSTaskTerminationReasonExit = 1,
        NSTaskTerminationReasonUncaughtSignal = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSTask;

    unsafe impl ClassType for NSTask {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSTask")]
    unsafe impl NSTask {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other executableURL)]
        pub unsafe fn executableURL(&self) -> Option<Id<Foundation::NSURL, Shared>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method(setExecutableURL:)]
        pub unsafe fn setExecutableURL(&self, executableURL: Option<&Foundation::NSURL>);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other arguments)]
        pub unsafe fn arguments(
            &self,
        ) -> Option<Id<Foundation::NSArray<Foundation::NSString>, Shared>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method(setArguments:)]
        pub unsafe fn setArguments(
            &self,
            arguments: Option<&Foundation::NSArray<Foundation::NSString>>,
        );

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other environment)]
        pub unsafe fn environment(
            &self,
        ) -> Option<Id<Foundation::NSDictionary<Foundation::NSString, Foundation::NSString>, Shared>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method(setEnvironment:)]
        pub unsafe fn setEnvironment(
            &self,
            environment: Option<
                &Foundation::NSDictionary<Foundation::NSString, Foundation::NSString>,
            >,
        );

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other currentDirectoryURL)]
        pub unsafe fn currentDirectoryURL(&self) -> Option<Id<Foundation::NSURL, Shared>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method(setCurrentDirectoryURL:)]
        pub unsafe fn setCurrentDirectoryURL(
            &self,
            currentDirectoryURL: Option<&Foundation::NSURL>,
        );

        #[method_id(@__retain_semantics Other standardInput)]
        pub unsafe fn standardInput(&self) -> Option<Id<Object, Shared>>;

        #[method(setStandardInput:)]
        pub unsafe fn setStandardInput(&self, standardInput: Option<&Object>);

        #[method_id(@__retain_semantics Other standardOutput)]
        pub unsafe fn standardOutput(&self) -> Option<Id<Object, Shared>>;

        #[method(setStandardOutput:)]
        pub unsafe fn setStandardOutput(&self, standardOutput: Option<&Object>);

        #[method_id(@__retain_semantics Other standardError)]
        pub unsafe fn standardError(&self) -> Option<Id<Object, Shared>>;

        #[method(setStandardError:)]
        pub unsafe fn setStandardError(&self, standardError: Option<&Object>);

        #[cfg(feature = "Foundation_NSError")]
        #[method(launchAndReturnError:_)]
        pub unsafe fn launchAndReturnError(&self) -> Result<(), Id<Foundation::NSError, Shared>>;

        #[method(interrupt)]
        pub unsafe fn interrupt(&self);

        #[method(terminate)]
        pub unsafe fn terminate(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self) -> bool;

        #[method(resume)]
        pub unsafe fn resume(&self) -> bool;

        #[method(processIdentifier)]
        pub unsafe fn processIdentifier(&self) -> c_int;

        #[method(isRunning)]
        pub unsafe fn isRunning(&self) -> bool;

        #[method(terminationStatus)]
        pub unsafe fn terminationStatus(&self) -> c_int;

        #[method(terminationReason)]
        pub unsafe fn terminationReason(&self) -> NSTaskTerminationReason;

        #[method(terminationHandler)]
        pub unsafe fn terminationHandler(&self) -> *mut Block<(NonNull<Foundation::NSTask>,), ()>;

        #[method(setTerminationHandler:)]
        pub unsafe fn setTerminationHandler(
            &self,
            terminationHandler: Option<&Block<(NonNull<Foundation::NSTask>,), ()>>,
        );

        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, qualityOfService: NSQualityOfService);
    }
);

extern_methods!(
    /// NSTaskConveniences
    #[cfg(feature = "Foundation_NSTask")]
    unsafe impl NSTask {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other launchedTaskWithExecutableURL:arguments:error:terminationHandler:)]
        pub unsafe fn launchedTaskWithExecutableURL_arguments_error_terminationHandler(
            url: &Foundation::NSURL,
            arguments: &Foundation::NSArray<Foundation::NSString>,
            error: *mut *mut Foundation::NSError,
            terminationHandler: Option<&Block<(NonNull<Foundation::NSTask>,), ()>>,
        ) -> Option<Id<Foundation::NSTask, Shared>>;

        #[method(waitUntilExit)]
        pub unsafe fn waitUntilExit(&self);
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "Foundation_NSTask")]
    unsafe impl NSTask {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other launchPath)]
        pub unsafe fn launchPath(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setLaunchPath:)]
        pub unsafe fn setLaunchPath(&self, launchPath: Option<&Foundation::NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other currentDirectoryPath)]
        pub unsafe fn currentDirectoryPath(&self) -> Id<Foundation::NSString, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setCurrentDirectoryPath:)]
        pub unsafe fn setCurrentDirectoryPath(&self, currentDirectoryPath: &Foundation::NSString);

        #[method(launch)]
        pub unsafe fn launch(&self);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other launchedTaskWithLaunchPath:arguments:)]
        pub unsafe fn launchedTaskWithLaunchPath_arguments(
            path: &Foundation::NSString,
            arguments: &Foundation::NSArray<Foundation::NSString>,
        ) -> Id<Foundation::NSTask, Shared>;
    }
);

extern_static!(NSTaskDidTerminateNotification: &'static Foundation::NSNotificationName);
