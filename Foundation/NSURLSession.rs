//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation;

extern_static!(NSURLSessionTransferSizeUnknown: i64);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSession;

    unsafe impl ClassType for NSURLSession {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSession")]
    unsafe impl NSURLSession {
        #[method_id(@__retain_semantics Other sharedSession)]
        pub unsafe fn sharedSession() -> Id<Foundation::NSURLSession, Shared>;

        #[cfg(feature = "Foundation_NSURLSessionConfiguration")]
        #[method_id(@__retain_semantics Other sessionWithConfiguration:)]
        pub unsafe fn sessionWithConfiguration(
            configuration: &Foundation::NSURLSessionConfiguration,
        ) -> Id<Foundation::NSURLSession, Shared>;

        #[cfg(all(
            feature = "Foundation_NSOperationQueue",
            feature = "Foundation_NSURLSessionConfiguration",
            feature = "Foundation_NSURLSessionDelegate"
        ))]
        #[method_id(@__retain_semantics Other sessionWithConfiguration:delegate:delegateQueue:)]
        pub unsafe fn sessionWithConfiguration_delegate_delegateQueue(
            configuration: &Foundation::NSURLSessionConfiguration,
            delegate: Option<&Foundation::NSURLSessionDelegate>,
            queue: Option<&Foundation::NSOperationQueue>,
        ) -> Id<Foundation::NSURLSession, Shared>;

        #[cfg(feature = "Foundation_NSOperationQueue")]
        #[method_id(@__retain_semantics Other delegateQueue)]
        pub unsafe fn delegateQueue(&self) -> Id<Foundation::NSOperationQueue, Shared>;

        #[cfg(feature = "Foundation_NSURLSessionDelegate")]
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<Foundation::NSURLSessionDelegate, Shared>>;

        #[cfg(feature = "Foundation_NSURLSessionConfiguration")]
        #[method_id(@__retain_semantics Other configuration)]
        pub unsafe fn configuration(&self) -> Id<Foundation::NSURLSessionConfiguration, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other sessionDescription)]
        pub unsafe fn sessionDescription(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setSessionDescription:)]
        pub unsafe fn setSessionDescription(
            &self,
            sessionDescription: Option<&Foundation::NSString>,
        );

        #[method(finishTasksAndInvalidate)]
        pub unsafe fn finishTasksAndInvalidate(&self);

        #[method(invalidateAndCancel)]
        pub unsafe fn invalidateAndCancel(&self);

        #[method(resetWithCompletionHandler:)]
        pub unsafe fn resetWithCompletionHandler(&self, completionHandler: &Block<(), ()>);

        #[method(flushWithCompletionHandler:)]
        pub unsafe fn flushWithCompletionHandler(&self, completionHandler: &Block<(), ()>);

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSURLSessionDataTask",
            feature = "Foundation_NSURLSessionDownloadTask",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method(getTasksWithCompletionHandler:)]
        pub unsafe fn getTasksWithCompletionHandler(
            &self,
            completionHandler: &Block<
                (
                    NonNull<Foundation::NSArray<Foundation::NSURLSessionDataTask>>,
                    NonNull<Foundation::NSArray<Foundation::NSURLSessionUploadTask>>,
                    NonNull<Foundation::NSArray<Foundation::NSURLSessionDownloadTask>>,
                ),
                (),
            >,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSURLSessionTask"
        ))]
        #[method(getAllTasksWithCompletionHandler:)]
        pub unsafe fn getAllTasksWithCompletionHandler(
            &self,
            completionHandler: &Block<
                (NonNull<Foundation::NSArray<Foundation::NSURLSessionTask>>,),
                (),
            >,
        );

        #[cfg(all(
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionDataTask"
        ))]
        #[method_id(@__retain_semantics Other dataTaskWithRequest:)]
        pub unsafe fn dataTaskWithRequest(
            &self,
            request: &Foundation::NSURLRequest,
        ) -> Id<Foundation::NSURLSessionDataTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLSessionDataTask"
        ))]
        #[method_id(@__retain_semantics Other dataTaskWithURL:)]
        pub unsafe fn dataTaskWithURL(
            &self,
            url: &Foundation::NSURL,
        ) -> Id<Foundation::NSURLSessionDataTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method_id(@__retain_semantics Other uploadTaskWithRequest:fromFile:)]
        pub unsafe fn uploadTaskWithRequest_fromFile(
            &self,
            request: &Foundation::NSURLRequest,
            fileURL: &Foundation::NSURL,
        ) -> Id<Foundation::NSURLSessionUploadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method_id(@__retain_semantics Other uploadTaskWithRequest:fromData:)]
        pub unsafe fn uploadTaskWithRequest_fromData(
            &self,
            request: &Foundation::NSURLRequest,
            bodyData: &Foundation::NSData,
        ) -> Id<Foundation::NSURLSessionUploadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method_id(@__retain_semantics Other uploadTaskWithStreamedRequest:)]
        pub unsafe fn uploadTaskWithStreamedRequest(
            &self,
            request: &Foundation::NSURLRequest,
        ) -> Id<Foundation::NSURLSessionUploadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithRequest:)]
        pub unsafe fn downloadTaskWithRequest(
            &self,
            request: &Foundation::NSURLRequest,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithURL:)]
        pub unsafe fn downloadTaskWithURL(
            &self,
            url: &Foundation::NSURL,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithResumeData:)]
        pub unsafe fn downloadTaskWithResumeData(
            &self,
            resumeData: &Foundation::NSData,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSString",
            feature = "Foundation_NSURLSessionStreamTask"
        ))]
        #[method_id(@__retain_semantics Other streamTaskWithHostName:port:)]
        pub unsafe fn streamTaskWithHostName_port(
            &self,
            hostname: &Foundation::NSString,
            port: NSInteger,
        ) -> Id<Foundation::NSURLSessionStreamTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSNetService",
            feature = "Foundation_NSURLSessionStreamTask"
        ))]
        #[method_id(@__retain_semantics Other streamTaskWithNetService:)]
        pub unsafe fn streamTaskWithNetService(
            &self,
            service: &Foundation::NSNetService,
        ) -> Id<Foundation::NSURLSessionStreamTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLSessionWebSocketTask"
        ))]
        #[method_id(@__retain_semantics Other webSocketTaskWithURL:)]
        pub unsafe fn webSocketTaskWithURL(
            &self,
            url: &Foundation::NSURL,
        ) -> Id<Foundation::NSURLSessionWebSocketTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLSessionWebSocketTask"
        ))]
        #[method_id(@__retain_semantics Other webSocketTaskWithURL:protocols:)]
        pub unsafe fn webSocketTaskWithURL_protocols(
            &self,
            url: &Foundation::NSURL,
            protocols: &Foundation::NSArray<Foundation::NSString>,
        ) -> Id<Foundation::NSURLSessionWebSocketTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLSessionWebSocketTask"
        ))]
        #[method_id(@__retain_semantics Other webSocketTaskWithRequest:)]
        pub unsafe fn webSocketTaskWithRequest(
            &self,
            request: &Foundation::NSURLRequest,
        ) -> Id<Foundation::NSURLSessionWebSocketTask, Shared>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_methods!(
    /// NSURLSessionAsynchronousConvenience
    #[cfg(feature = "Foundation_NSURLSession")]
    unsafe impl NSURLSession {
        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionDataTask"
        ))]
        #[method_id(@__retain_semantics Other dataTaskWithRequest:completionHandler:)]
        pub unsafe fn dataTaskWithRequest_completionHandler(
            &self,
            request: &Foundation::NSURLRequest,
            completionHandler: &Block<
                (
                    *mut Foundation::NSData,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionDataTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionDataTask"
        ))]
        #[method_id(@__retain_semantics Other dataTaskWithURL:completionHandler:)]
        pub unsafe fn dataTaskWithURL_completionHandler(
            &self,
            url: &Foundation::NSURL,
            completionHandler: &Block<
                (
                    *mut Foundation::NSData,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionDataTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method_id(@__retain_semantics Other uploadTaskWithRequest:fromFile:completionHandler:)]
        pub unsafe fn uploadTaskWithRequest_fromFile_completionHandler(
            &self,
            request: &Foundation::NSURLRequest,
            fileURL: &Foundation::NSURL,
            completionHandler: &Block<
                (
                    *mut Foundation::NSData,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionUploadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionUploadTask"
        ))]
        #[method_id(@__retain_semantics Other uploadTaskWithRequest:fromData:completionHandler:)]
        pub unsafe fn uploadTaskWithRequest_fromData_completionHandler(
            &self,
            request: &Foundation::NSURLRequest,
            bodyData: Option<&Foundation::NSData>,
            completionHandler: &Block<
                (
                    *mut Foundation::NSData,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionUploadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithRequest:completionHandler:)]
        pub unsafe fn downloadTaskWithRequest_completionHandler(
            &self,
            request: &Foundation::NSURLRequest,
            completionHandler: &Block<
                (
                    *mut Foundation::NSURL,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithURL:completionHandler:)]
        pub unsafe fn downloadTaskWithURL_completionHandler(
            &self,
            url: &Foundation::NSURL,
            completionHandler: &Block<
                (
                    *mut Foundation::NSURL,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL",
            feature = "Foundation_NSURLResponse",
            feature = "Foundation_NSURLSessionDownloadTask"
        ))]
        #[method_id(@__retain_semantics Other downloadTaskWithResumeData:completionHandler:)]
        pub unsafe fn downloadTaskWithResumeData_completionHandler(
            &self,
            resumeData: &Foundation::NSData,
            completionHandler: &Block<
                (
                    *mut Foundation::NSURL,
                    *mut Foundation::NSURLResponse,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        ) -> Id<Foundation::NSURLSessionDownloadTask, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionTaskState {
        NSURLSessionTaskStateRunning = 0,
        NSURLSessionTaskStateSuspended = 1,
        NSURLSessionTaskStateCanceling = 2,
        NSURLSessionTaskStateCompleted = 3,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTask;

    unsafe impl ClassType for NSURLSessionTask {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionTask")]
    unsafe impl NSURLSessionTask {
        #[method(taskIdentifier)]
        pub unsafe fn taskIdentifier(&self) -> NSUInteger;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method_id(@__retain_semantics Other originalRequest)]
        pub unsafe fn originalRequest(&self) -> Option<Id<Foundation::NSURLRequest, Shared>>;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method_id(@__retain_semantics Other currentRequest)]
        pub unsafe fn currentRequest(&self) -> Option<Id<Foundation::NSURLRequest, Shared>>;

        #[cfg(feature = "Foundation_NSURLResponse")]
        #[method_id(@__retain_semantics Other response)]
        pub unsafe fn response(&self) -> Option<Id<Foundation::NSURLResponse, Shared>>;

        #[cfg(feature = "Foundation_NSURLSessionTaskDelegate")]
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<Foundation::NSURLSessionTaskDelegate, Shared>>;

        #[cfg(feature = "Foundation_NSURLSessionTaskDelegate")]
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(&self, delegate: Option<&Foundation::NSURLSessionTaskDelegate>);

        #[cfg(feature = "Foundation_NSProgress")]
        #[method_id(@__retain_semantics Other progress)]
        pub unsafe fn progress(&self) -> Id<Foundation::NSProgress, Shared>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other earliestBeginDate)]
        pub unsafe fn earliestBeginDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method(setEarliestBeginDate:)]
        pub unsafe fn setEarliestBeginDate(&self, earliestBeginDate: Option<&Foundation::NSDate>);

        #[method(countOfBytesClientExpectsToSend)]
        pub unsafe fn countOfBytesClientExpectsToSend(&self) -> i64;

        #[method(setCountOfBytesClientExpectsToSend:)]
        pub unsafe fn setCountOfBytesClientExpectsToSend(
            &self,
            countOfBytesClientExpectsToSend: i64,
        );

        #[method(countOfBytesClientExpectsToReceive)]
        pub unsafe fn countOfBytesClientExpectsToReceive(&self) -> i64;

        #[method(setCountOfBytesClientExpectsToReceive:)]
        pub unsafe fn setCountOfBytesClientExpectsToReceive(
            &self,
            countOfBytesClientExpectsToReceive: i64,
        );

        #[method(countOfBytesSent)]
        pub unsafe fn countOfBytesSent(&self) -> i64;

        #[method(countOfBytesReceived)]
        pub unsafe fn countOfBytesReceived(&self) -> i64;

        #[method(countOfBytesExpectedToSend)]
        pub unsafe fn countOfBytesExpectedToSend(&self) -> i64;

        #[method(countOfBytesExpectedToReceive)]
        pub unsafe fn countOfBytesExpectedToReceive(&self) -> i64;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other taskDescription)]
        pub unsafe fn taskDescription(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setTaskDescription:)]
        pub unsafe fn setTaskDescription(&self, taskDescription: Option<&Foundation::NSString>);

        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[method(state)]
        pub unsafe fn state(&self) -> NSURLSessionTaskState;

        #[cfg(feature = "Foundation_NSError")]
        #[method_id(@__retain_semantics Other error)]
        pub unsafe fn error(&self) -> Option<Id<Foundation::NSError, Shared>>;

        #[method(suspend)]
        pub unsafe fn suspend(&self);

        #[method(resume)]
        pub unsafe fn resume(&self);

        #[method(priority)]
        pub unsafe fn priority(&self) -> c_float;

        #[method(setPriority:)]
        pub unsafe fn setPriority(&self, priority: c_float);

        #[method(prefersIncrementalDelivery)]
        pub unsafe fn prefersIncrementalDelivery(&self) -> bool;

        #[method(setPrefersIncrementalDelivery:)]
        pub unsafe fn setPrefersIncrementalDelivery(&self, prefersIncrementalDelivery: bool);

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_static!(NSURLSessionTaskPriorityDefault: c_float);

extern_static!(NSURLSessionTaskPriorityLow: c_float);

extern_static!(NSURLSessionTaskPriorityHigh: c_float);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionDataTask;

    unsafe impl ClassType for NSURLSessionDataTask {
        #[inherits(NSObject)]
        type Super = NSURLSessionTask;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionDataTask")]
    unsafe impl NSURLSessionDataTask {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionUploadTask;

    unsafe impl ClassType for NSURLSessionUploadTask {
        #[inherits(NSURLSessionTask, NSObject)]
        type Super = NSURLSessionDataTask;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionUploadTask")]
    unsafe impl NSURLSessionUploadTask {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionDownloadTask;

    unsafe impl ClassType for NSURLSessionDownloadTask {
        #[inherits(NSObject)]
        type Super = NSURLSessionTask;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionDownloadTask")]
    unsafe impl NSURLSessionDownloadTask {
        #[cfg(feature = "Foundation_NSData")]
        #[method(cancelByProducingResumeData:)]
        pub unsafe fn cancelByProducingResumeData(
            &self,
            completionHandler: &Block<(*mut Foundation::NSData,), ()>,
        );

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionStreamTask;

    unsafe impl ClassType for NSURLSessionStreamTask {
        #[inherits(NSObject)]
        type Super = NSURLSessionTask;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionStreamTask")]
    unsafe impl NSURLSessionStreamTask {
        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method(readDataOfMinLength:maxLength:timeout:completionHandler:)]
        pub unsafe fn readDataOfMinLength_maxLength_timeout_completionHandler(
            &self,
            minBytes: NSUInteger,
            maxBytes: NSUInteger,
            timeout: NSTimeInterval,
            completionHandler: &Block<
                (*mut Foundation::NSData, Bool, *mut Foundation::NSError),
                (),
            >,
        );

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method(writeData:timeout:completionHandler:)]
        pub unsafe fn writeData_timeout_completionHandler(
            &self,
            data: &Foundation::NSData,
            timeout: NSTimeInterval,
            completionHandler: &Block<(*mut Foundation::NSError,), ()>,
        );

        #[method(captureStreams)]
        pub unsafe fn captureStreams(&self);

        #[method(closeWrite)]
        pub unsafe fn closeWrite(&self);

        #[method(closeRead)]
        pub unsafe fn closeRead(&self);

        #[method(startSecureConnection)]
        pub unsafe fn startSecureConnection(&self);

        #[method(stopSecureConnection)]
        pub unsafe fn stopSecureConnection(&self);

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionWebSocketMessageType {
        NSURLSessionWebSocketMessageTypeData = 0,
        NSURLSessionWebSocketMessageTypeString = 1,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionWebSocketMessage;

    unsafe impl ClassType for NSURLSessionWebSocketMessage {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionWebSocketMessage")]
    unsafe impl NSURLSessionWebSocketMessage {
        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Init initWithData:)]
        pub unsafe fn initWithData(
            this: Option<Allocated<Self>>,
            data: &Foundation::NSData,
        ) -> Id<Self, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithString:)]
        pub unsafe fn initWithString(
            this: Option<Allocated<Self>>,
            string: &Foundation::NSString,
        ) -> Id<Self, Shared>;

        #[method(type)]
        pub unsafe fn type_(&self) -> NSURLSessionWebSocketMessageType;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other data)]
        pub unsafe fn data(&self) -> Option<Id<Foundation::NSData, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other string)]
        pub unsafe fn string(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionWebSocketCloseCode {
        NSURLSessionWebSocketCloseCodeInvalid = 0,
        NSURLSessionWebSocketCloseCodeNormalClosure = 1000,
        NSURLSessionWebSocketCloseCodeGoingAway = 1001,
        NSURLSessionWebSocketCloseCodeProtocolError = 1002,
        NSURLSessionWebSocketCloseCodeUnsupportedData = 1003,
        NSURLSessionWebSocketCloseCodeNoStatusReceived = 1005,
        NSURLSessionWebSocketCloseCodeAbnormalClosure = 1006,
        NSURLSessionWebSocketCloseCodeInvalidFramePayloadData = 1007,
        NSURLSessionWebSocketCloseCodePolicyViolation = 1008,
        NSURLSessionWebSocketCloseCodeMessageTooBig = 1009,
        NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing = 1010,
        NSURLSessionWebSocketCloseCodeInternalServerError = 1011,
        NSURLSessionWebSocketCloseCodeTLSHandshakeFailure = 1015,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionWebSocketTask;

    unsafe impl ClassType for NSURLSessionWebSocketTask {
        #[inherits(NSObject)]
        type Super = NSURLSessionTask;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionWebSocketTask")]
    unsafe impl NSURLSessionWebSocketTask {
        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLSessionWebSocketMessage"
        ))]
        #[method(sendMessage:completionHandler:)]
        pub unsafe fn sendMessage_completionHandler(
            &self,
            message: &Foundation::NSURLSessionWebSocketMessage,
            completionHandler: &Block<(*mut Foundation::NSError,), ()>,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLSessionWebSocketMessage"
        ))]
        #[method(receiveMessageWithCompletionHandler:)]
        pub unsafe fn receiveMessageWithCompletionHandler(
            &self,
            completionHandler: &Block<
                (
                    *mut Foundation::NSURLSessionWebSocketMessage,
                    *mut Foundation::NSError,
                ),
                (),
            >,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(sendPingWithPongReceiveHandler:)]
        pub unsafe fn sendPingWithPongReceiveHandler(
            &self,
            pongReceiveHandler: &Block<(*mut Foundation::NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSData")]
        #[method(cancelWithCloseCode:reason:)]
        pub unsafe fn cancelWithCloseCode_reason(
            &self,
            closeCode: NSURLSessionWebSocketCloseCode,
            reason: Option<&Foundation::NSData>,
        );

        #[method(maximumMessageSize)]
        pub unsafe fn maximumMessageSize(&self) -> NSInteger;

        #[method(setMaximumMessageSize:)]
        pub unsafe fn setMaximumMessageSize(&self, maximumMessageSize: NSInteger);

        #[method(closeCode)]
        pub unsafe fn closeCode(&self) -> NSURLSessionWebSocketCloseCode;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other closeReason)]
        pub unsafe fn closeReason(&self) -> Option<Id<Foundation::NSData, Shared>>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionMultipathServiceType {
        NSURLSessionMultipathServiceTypeNone = 0,
        NSURLSessionMultipathServiceTypeHandover = 1,
        NSURLSessionMultipathServiceTypeInteractive = 2,
        NSURLSessionMultipathServiceTypeAggregate = 3,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionConfiguration;

    unsafe impl ClassType for NSURLSessionConfiguration {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionConfiguration")]
    unsafe impl NSURLSessionConfiguration {
        #[method_id(@__retain_semantics Other defaultSessionConfiguration)]
        pub unsafe fn defaultSessionConfiguration(
        ) -> Id<Foundation::NSURLSessionConfiguration, Shared>;

        #[method_id(@__retain_semantics Other ephemeralSessionConfiguration)]
        pub unsafe fn ephemeralSessionConfiguration(
        ) -> Id<Foundation::NSURLSessionConfiguration, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other backgroundSessionConfigurationWithIdentifier:)]
        pub unsafe fn backgroundSessionConfigurationWithIdentifier(
            identifier: &Foundation::NSString,
        ) -> Id<Foundation::NSURLSessionConfiguration, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other identifier)]
        pub unsafe fn identifier(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[method(requestCachePolicy)]
        pub unsafe fn requestCachePolicy(&self) -> NSURLRequestCachePolicy;

        #[method(setRequestCachePolicy:)]
        pub unsafe fn setRequestCachePolicy(&self, requestCachePolicy: NSURLRequestCachePolicy);

        #[method(timeoutIntervalForRequest)]
        pub unsafe fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        #[method(setTimeoutIntervalForRequest:)]
        pub unsafe fn setTimeoutIntervalForRequest(
            &self,
            timeoutIntervalForRequest: NSTimeInterval,
        );

        #[method(timeoutIntervalForResource)]
        pub unsafe fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        #[method(setTimeoutIntervalForResource:)]
        pub unsafe fn setTimeoutIntervalForResource(
            &self,
            timeoutIntervalForResource: NSTimeInterval,
        );

        #[method(networkServiceType)]
        pub unsafe fn networkServiceType(&self) -> NSURLRequestNetworkServiceType;

        #[method(setNetworkServiceType:)]
        pub unsafe fn setNetworkServiceType(
            &self,
            networkServiceType: NSURLRequestNetworkServiceType,
        );

        #[method(allowsCellularAccess)]
        pub unsafe fn allowsCellularAccess(&self) -> bool;

        #[method(setAllowsCellularAccess:)]
        pub unsafe fn setAllowsCellularAccess(&self, allowsCellularAccess: bool);

        #[method(allowsExpensiveNetworkAccess)]
        pub unsafe fn allowsExpensiveNetworkAccess(&self) -> bool;

        #[method(setAllowsExpensiveNetworkAccess:)]
        pub unsafe fn setAllowsExpensiveNetworkAccess(&self, allowsExpensiveNetworkAccess: bool);

        #[method(allowsConstrainedNetworkAccess)]
        pub unsafe fn allowsConstrainedNetworkAccess(&self) -> bool;

        #[method(setAllowsConstrainedNetworkAccess:)]
        pub unsafe fn setAllowsConstrainedNetworkAccess(
            &self,
            allowsConstrainedNetworkAccess: bool,
        );

        #[method(waitsForConnectivity)]
        pub unsafe fn waitsForConnectivity(&self) -> bool;

        #[method(setWaitsForConnectivity:)]
        pub unsafe fn setWaitsForConnectivity(&self, waitsForConnectivity: bool);

        #[method(isDiscretionary)]
        pub unsafe fn isDiscretionary(&self) -> bool;

        #[method(setDiscretionary:)]
        pub unsafe fn setDiscretionary(&self, discretionary: bool);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other sharedContainerIdentifier)]
        pub unsafe fn sharedContainerIdentifier(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setSharedContainerIdentifier:)]
        pub unsafe fn setSharedContainerIdentifier(
            &self,
            sharedContainerIdentifier: Option<&Foundation::NSString>,
        );

        #[method(sessionSendsLaunchEvents)]
        pub unsafe fn sessionSendsLaunchEvents(&self) -> bool;

        #[method(setSessionSendsLaunchEvents:)]
        pub unsafe fn setSessionSendsLaunchEvents(&self, sessionSendsLaunchEvents: bool);

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method_id(@__retain_semantics Other connectionProxyDictionary)]
        pub unsafe fn connectionProxyDictionary(
            &self,
        ) -> Option<Id<Foundation::NSDictionary, Shared>>;

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method(setConnectionProxyDictionary:)]
        pub unsafe fn setConnectionProxyDictionary(
            &self,
            connectionProxyDictionary: Option<&Foundation::NSDictionary>,
        );

        #[method(HTTPShouldUsePipelining)]
        pub unsafe fn HTTPShouldUsePipelining(&self) -> bool;

        #[method(setHTTPShouldUsePipelining:)]
        pub unsafe fn setHTTPShouldUsePipelining(&self, HTTPShouldUsePipelining: bool);

        #[method(HTTPShouldSetCookies)]
        pub unsafe fn HTTPShouldSetCookies(&self) -> bool;

        #[method(setHTTPShouldSetCookies:)]
        pub unsafe fn setHTTPShouldSetCookies(&self, HTTPShouldSetCookies: bool);

        #[method(HTTPCookieAcceptPolicy)]
        pub unsafe fn HTTPCookieAcceptPolicy(&self) -> NSHTTPCookieAcceptPolicy;

        #[method(setHTTPCookieAcceptPolicy:)]
        pub unsafe fn setHTTPCookieAcceptPolicy(
            &self,
            HTTPCookieAcceptPolicy: NSHTTPCookieAcceptPolicy,
        );

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method_id(@__retain_semantics Other HTTPAdditionalHeaders)]
        pub unsafe fn HTTPAdditionalHeaders(&self) -> Option<Id<Foundation::NSDictionary, Shared>>;

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method(setHTTPAdditionalHeaders:)]
        pub unsafe fn setHTTPAdditionalHeaders(
            &self,
            HTTPAdditionalHeaders: Option<&Foundation::NSDictionary>,
        );

        #[method(HTTPMaximumConnectionsPerHost)]
        pub unsafe fn HTTPMaximumConnectionsPerHost(&self) -> NSInteger;

        #[method(setHTTPMaximumConnectionsPerHost:)]
        pub unsafe fn setHTTPMaximumConnectionsPerHost(
            &self,
            HTTPMaximumConnectionsPerHost: NSInteger,
        );

        #[cfg(feature = "Foundation_NSHTTPCookieStorage")]
        #[method_id(@__retain_semantics Other HTTPCookieStorage)]
        pub unsafe fn HTTPCookieStorage(
            &self,
        ) -> Option<Id<Foundation::NSHTTPCookieStorage, Shared>>;

        #[cfg(feature = "Foundation_NSHTTPCookieStorage")]
        #[method(setHTTPCookieStorage:)]
        pub unsafe fn setHTTPCookieStorage(
            &self,
            HTTPCookieStorage: Option<&Foundation::NSHTTPCookieStorage>,
        );

        #[cfg(feature = "Foundation_NSURLCredentialStorage")]
        #[method_id(@__retain_semantics Other URLCredentialStorage)]
        pub unsafe fn URLCredentialStorage(
            &self,
        ) -> Option<Id<Foundation::NSURLCredentialStorage, Shared>>;

        #[cfg(feature = "Foundation_NSURLCredentialStorage")]
        #[method(setURLCredentialStorage:)]
        pub unsafe fn setURLCredentialStorage(
            &self,
            URLCredentialStorage: Option<&Foundation::NSURLCredentialStorage>,
        );

        #[cfg(feature = "Foundation_NSURLCache")]
        #[method_id(@__retain_semantics Other URLCache)]
        pub unsafe fn URLCache(&self) -> Option<Id<Foundation::NSURLCache, Shared>>;

        #[cfg(feature = "Foundation_NSURLCache")]
        #[method(setURLCache:)]
        pub unsafe fn setURLCache(&self, URLCache: Option<&Foundation::NSURLCache>);

        #[method(shouldUseExtendedBackgroundIdleMode)]
        pub unsafe fn shouldUseExtendedBackgroundIdleMode(&self) -> bool;

        #[method(setShouldUseExtendedBackgroundIdleMode:)]
        pub unsafe fn setShouldUseExtendedBackgroundIdleMode(
            &self,
            shouldUseExtendedBackgroundIdleMode: bool,
        );

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other protocolClasses)]
        pub unsafe fn protocolClasses(&self) -> Option<Id<Foundation::NSArray<TodoClass>, Shared>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method(setProtocolClasses:)]
        pub unsafe fn setProtocolClasses(
            &self,
            protocolClasses: Option<&Foundation::NSArray<TodoClass>>,
        );

        #[method(multipathServiceType)]
        pub unsafe fn multipathServiceType(&self) -> NSURLSessionMultipathServiceType;

        #[method(setMultipathServiceType:)]
        pub unsafe fn setMultipathServiceType(
            &self,
            multipathServiceType: NSURLSessionMultipathServiceType,
        );

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionDelayedRequestDisposition {
        NSURLSessionDelayedRequestContinueLoading = 0,
        NSURLSessionDelayedRequestUseNewRequest = 1,
        NSURLSessionDelayedRequestCancel = 2,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionAuthChallengeDisposition {
        NSURLSessionAuthChallengeUseCredential = 0,
        NSURLSessionAuthChallengePerformDefaultHandling = 1,
        NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,
        NSURLSessionAuthChallengeRejectProtectionSpace = 3,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionResponseDisposition {
        NSURLSessionResponseCancel = 0,
        NSURLSessionResponseAllow = 1,
        NSURLSessionResponseBecomeDownload = 2,
        NSURLSessionResponseBecomeStream = 3,
    }
);

extern_protocol!(
    pub struct NSURLSessionDelegate;

    unsafe impl ProtocolType for NSURLSessionDelegate {
        #[optional]
        #[method(URLSession:didBecomeInvalidWithError:)]
        pub unsafe fn URLSession_didBecomeInvalidWithError(
            &self,
            session: &Foundation::NSURLSession,
            error: Option<&Foundation::NSError>,
        );

        #[optional]
        #[method(URLSession:didReceiveChallenge:completionHandler:)]
        pub unsafe fn URLSession_didReceiveChallenge_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            challenge: &Foundation::NSURLAuthenticationChallenge,
            completionHandler: &Block<
                (
                    NSURLSessionAuthChallengeDisposition,
                    *mut Foundation::NSURLCredential,
                ),
                (),
            >,
        );

        #[optional]
        #[method(URLSessionDidFinishEventsForBackgroundURLSession:)]
        pub unsafe fn URLSessionDidFinishEventsForBackgroundURLSession(
            &self,
            session: &Foundation::NSURLSession,
        );
    }
);

extern_protocol!(
    pub struct NSURLSessionTaskDelegate;

    unsafe impl ProtocolType for NSURLSessionTaskDelegate {
        #[optional]
        #[method(URLSession:task:willBeginDelayedRequest:completionHandler:)]
        pub unsafe fn URLSession_task_willBeginDelayedRequest_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            request: &Foundation::NSURLRequest,
            completionHandler: &Block<
                (
                    NSURLSessionDelayedRequestDisposition,
                    *mut Foundation::NSURLRequest,
                ),
                (),
            >,
        );

        #[optional]
        #[method(URLSession:taskIsWaitingForConnectivity:)]
        pub unsafe fn URLSession_taskIsWaitingForConnectivity(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
        );

        #[optional]
        #[method(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]
        pub unsafe fn URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            response: &Foundation::NSHTTPURLResponse,
            request: &Foundation::NSURLRequest,
            completionHandler: &Block<(*mut Foundation::NSURLRequest,), ()>,
        );

        #[optional]
        #[method(URLSession:task:didReceiveChallenge:completionHandler:)]
        pub unsafe fn URLSession_task_didReceiveChallenge_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            challenge: &Foundation::NSURLAuthenticationChallenge,
            completionHandler: &Block<
                (
                    NSURLSessionAuthChallengeDisposition,
                    *mut Foundation::NSURLCredential,
                ),
                (),
            >,
        );

        #[optional]
        #[method(URLSession:task:needNewBodyStream:)]
        pub unsafe fn URLSession_task_needNewBodyStream(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            completionHandler: &Block<(*mut Foundation::NSInputStream,), ()>,
        );

        #[optional]
        #[method(URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)]
        pub unsafe fn URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            bytesSent: i64,
            totalBytesSent: i64,
            totalBytesExpectedToSend: i64,
        );

        #[optional]
        #[method(URLSession:task:didFinishCollectingMetrics:)]
        pub unsafe fn URLSession_task_didFinishCollectingMetrics(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            metrics: &Foundation::NSURLSessionTaskMetrics,
        );

        #[optional]
        #[method(URLSession:task:didCompleteWithError:)]
        pub unsafe fn URLSession_task_didCompleteWithError(
            &self,
            session: &Foundation::NSURLSession,
            task: &Foundation::NSURLSessionTask,
            error: Option<&Foundation::NSError>,
        );
    }
);

extern_protocol!(
    pub struct NSURLSessionDataDelegate;

    unsafe impl ProtocolType for NSURLSessionDataDelegate {
        #[optional]
        #[method(URLSession:dataTask:didReceiveResponse:completionHandler:)]
        pub unsafe fn URLSession_dataTask_didReceiveResponse_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            dataTask: &Foundation::NSURLSessionDataTask,
            response: &Foundation::NSURLResponse,
            completionHandler: &Block<(NSURLSessionResponseDisposition,), ()>,
        );

        #[optional]
        #[method(URLSession:dataTask:didBecomeDownloadTask:)]
        pub unsafe fn URLSession_dataTask_didBecomeDownloadTask(
            &self,
            session: &Foundation::NSURLSession,
            dataTask: &Foundation::NSURLSessionDataTask,
            downloadTask: &Foundation::NSURLSessionDownloadTask,
        );

        #[optional]
        #[method(URLSession:dataTask:didBecomeStreamTask:)]
        pub unsafe fn URLSession_dataTask_didBecomeStreamTask(
            &self,
            session: &Foundation::NSURLSession,
            dataTask: &Foundation::NSURLSessionDataTask,
            streamTask: &Foundation::NSURLSessionStreamTask,
        );

        #[optional]
        #[method(URLSession:dataTask:didReceiveData:)]
        pub unsafe fn URLSession_dataTask_didReceiveData(
            &self,
            session: &Foundation::NSURLSession,
            dataTask: &Foundation::NSURLSessionDataTask,
            data: &Foundation::NSData,
        );

        #[optional]
        #[method(URLSession:dataTask:willCacheResponse:completionHandler:)]
        pub unsafe fn URLSession_dataTask_willCacheResponse_completionHandler(
            &self,
            session: &Foundation::NSURLSession,
            dataTask: &Foundation::NSURLSessionDataTask,
            proposedResponse: &Foundation::NSCachedURLResponse,
            completionHandler: &Block<(*mut Foundation::NSCachedURLResponse,), ()>,
        );
    }
);

extern_protocol!(
    pub struct NSURLSessionDownloadDelegate;

    unsafe impl ProtocolType for NSURLSessionDownloadDelegate {
        #[method(URLSession:downloadTask:didFinishDownloadingToURL:)]
        pub unsafe fn URLSession_downloadTask_didFinishDownloadingToURL(
            &self,
            session: &Foundation::NSURLSession,
            downloadTask: &Foundation::NSURLSessionDownloadTask,
            location: &Foundation::NSURL,
        );

        #[optional]
        #[method(URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)]
        pub unsafe fn URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(
            &self,
            session: &Foundation::NSURLSession,
            downloadTask: &Foundation::NSURLSessionDownloadTask,
            bytesWritten: i64,
            totalBytesWritten: i64,
            totalBytesExpectedToWrite: i64,
        );

        #[optional]
        #[method(URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:)]
        pub unsafe fn URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(
            &self,
            session: &Foundation::NSURLSession,
            downloadTask: &Foundation::NSURLSessionDownloadTask,
            fileOffset: i64,
            expectedTotalBytes: i64,
        );
    }
);

extern_protocol!(
    pub struct NSURLSessionStreamDelegate;

    unsafe impl ProtocolType for NSURLSessionStreamDelegate {
        #[optional]
        #[method(URLSession:readClosedForStreamTask:)]
        pub unsafe fn URLSession_readClosedForStreamTask(
            &self,
            session: &Foundation::NSURLSession,
            streamTask: &Foundation::NSURLSessionStreamTask,
        );

        #[optional]
        #[method(URLSession:writeClosedForStreamTask:)]
        pub unsafe fn URLSession_writeClosedForStreamTask(
            &self,
            session: &Foundation::NSURLSession,
            streamTask: &Foundation::NSURLSessionStreamTask,
        );

        #[optional]
        #[method(URLSession:betterRouteDiscoveredForStreamTask:)]
        pub unsafe fn URLSession_betterRouteDiscoveredForStreamTask(
            &self,
            session: &Foundation::NSURLSession,
            streamTask: &Foundation::NSURLSessionStreamTask,
        );

        #[optional]
        #[method(URLSession:streamTask:didBecomeInputStream:outputStream:)]
        pub unsafe fn URLSession_streamTask_didBecomeInputStream_outputStream(
            &self,
            session: &Foundation::NSURLSession,
            streamTask: &Foundation::NSURLSessionStreamTask,
            inputStream: &Foundation::NSInputStream,
            outputStream: &Foundation::NSOutputStream,
        );
    }
);

extern_protocol!(
    pub struct NSURLSessionWebSocketDelegate;

    unsafe impl ProtocolType for NSURLSessionWebSocketDelegate {
        #[optional]
        #[method(URLSession:webSocketTask:didOpenWithProtocol:)]
        pub unsafe fn URLSession_webSocketTask_didOpenWithProtocol(
            &self,
            session: &Foundation::NSURLSession,
            webSocketTask: &Foundation::NSURLSessionWebSocketTask,
            protocol: Option<&Foundation::NSString>,
        );

        #[optional]
        #[method(URLSession:webSocketTask:didCloseWithCode:reason:)]
        pub unsafe fn URLSession_webSocketTask_didCloseWithCode_reason(
            &self,
            session: &Foundation::NSURLSession,
            webSocketTask: &Foundation::NSURLSessionWebSocketTask,
            closeCode: NSURLSessionWebSocketCloseCode,
            reason: Option<&Foundation::NSData>,
        );
    }
);

extern_static!(NSURLSessionDownloadTaskResumeData: &'static Foundation::NSString);

extern_methods!(
    /// NSURLSessionDeprecated
    #[cfg(feature = "Foundation_NSURLSessionConfiguration")]
    unsafe impl NSURLSessionConfiguration {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other backgroundSessionConfiguration:)]
        pub unsafe fn backgroundSessionConfiguration(
            identifier: &Foundation::NSString,
        ) -> Id<Foundation::NSURLSessionConfiguration, Shared>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionTaskMetricsResourceFetchType {
        NSURLSessionTaskMetricsResourceFetchTypeUnknown = 0,
        NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad = 1,
        NSURLSessionTaskMetricsResourceFetchTypeServerPush = 2,
        NSURLSessionTaskMetricsResourceFetchTypeLocalCache = 3,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSURLSessionTaskMetricsDomainResolutionProtocol {
        NSURLSessionTaskMetricsDomainResolutionProtocolUnknown = 0,
        NSURLSessionTaskMetricsDomainResolutionProtocolUDP = 1,
        NSURLSessionTaskMetricsDomainResolutionProtocolTCP = 2,
        NSURLSessionTaskMetricsDomainResolutionProtocolTLS = 3,
        NSURLSessionTaskMetricsDomainResolutionProtocolHTTPS = 4,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTaskTransactionMetrics;

    unsafe impl ClassType for NSURLSessionTaskTransactionMetrics {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionTaskTransactionMetrics")]
    unsafe impl NSURLSessionTaskTransactionMetrics {
        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method_id(@__retain_semantics Other request)]
        pub unsafe fn request(&self) -> Id<Foundation::NSURLRequest, Shared>;

        #[cfg(feature = "Foundation_NSURLResponse")]
        #[method_id(@__retain_semantics Other response)]
        pub unsafe fn response(&self) -> Option<Id<Foundation::NSURLResponse, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other fetchStartDate)]
        pub unsafe fn fetchStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other domainLookupStartDate)]
        pub unsafe fn domainLookupStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other domainLookupEndDate)]
        pub unsafe fn domainLookupEndDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other connectStartDate)]
        pub unsafe fn connectStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other secureConnectionStartDate)]
        pub unsafe fn secureConnectionStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other secureConnectionEndDate)]
        pub unsafe fn secureConnectionEndDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other connectEndDate)]
        pub unsafe fn connectEndDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other requestStartDate)]
        pub unsafe fn requestStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other requestEndDate)]
        pub unsafe fn requestEndDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other responseStartDate)]
        pub unsafe fn responseStartDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other responseEndDate)]
        pub unsafe fn responseEndDate(&self) -> Option<Id<Foundation::NSDate, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other networkProtocolName)]
        pub unsafe fn networkProtocolName(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[method(isProxyConnection)]
        pub unsafe fn isProxyConnection(&self) -> bool;

        #[method(isReusedConnection)]
        pub unsafe fn isReusedConnection(&self) -> bool;

        #[method(resourceFetchType)]
        pub unsafe fn resourceFetchType(&self) -> NSURLSessionTaskMetricsResourceFetchType;

        #[method(countOfRequestHeaderBytesSent)]
        pub unsafe fn countOfRequestHeaderBytesSent(&self) -> i64;

        #[method(countOfRequestBodyBytesSent)]
        pub unsafe fn countOfRequestBodyBytesSent(&self) -> i64;

        #[method(countOfRequestBodyBytesBeforeEncoding)]
        pub unsafe fn countOfRequestBodyBytesBeforeEncoding(&self) -> i64;

        #[method(countOfResponseHeaderBytesReceived)]
        pub unsafe fn countOfResponseHeaderBytesReceived(&self) -> i64;

        #[method(countOfResponseBodyBytesReceived)]
        pub unsafe fn countOfResponseBodyBytesReceived(&self) -> i64;

        #[method(countOfResponseBodyBytesAfterDecoding)]
        pub unsafe fn countOfResponseBodyBytesAfterDecoding(&self) -> i64;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other localAddress)]
        pub unsafe fn localAddress(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSNumber")]
        #[method_id(@__retain_semantics Other localPort)]
        pub unsafe fn localPort(&self) -> Option<Id<Foundation::NSNumber, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other remoteAddress)]
        pub unsafe fn remoteAddress(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSNumber")]
        #[method_id(@__retain_semantics Other remotePort)]
        pub unsafe fn remotePort(&self) -> Option<Id<Foundation::NSNumber, Shared>>;

        #[cfg(feature = "Foundation_NSNumber")]
        #[method_id(@__retain_semantics Other negotiatedTLSProtocolVersion)]
        pub unsafe fn negotiatedTLSProtocolVersion(
            &self,
        ) -> Option<Id<Foundation::NSNumber, Shared>>;

        #[cfg(feature = "Foundation_NSNumber")]
        #[method_id(@__retain_semantics Other negotiatedTLSCipherSuite)]
        pub unsafe fn negotiatedTLSCipherSuite(&self) -> Option<Id<Foundation::NSNumber, Shared>>;

        #[method(isCellular)]
        pub unsafe fn isCellular(&self) -> bool;

        #[method(isExpensive)]
        pub unsafe fn isExpensive(&self) -> bool;

        #[method(isConstrained)]
        pub unsafe fn isConstrained(&self) -> bool;

        #[method(isMultipath)]
        pub unsafe fn isMultipath(&self) -> bool;

        #[method(domainResolutionProtocol)]
        pub unsafe fn domainResolutionProtocol(
            &self,
        ) -> NSURLSessionTaskMetricsDomainResolutionProtocol;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTaskMetrics;

    unsafe impl ClassType for NSURLSessionTaskMetrics {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSURLSessionTaskMetrics")]
    unsafe impl NSURLSessionTaskMetrics {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSURLSessionTaskTransactionMetrics"
        ))]
        #[method_id(@__retain_semantics Other transactionMetrics)]
        pub unsafe fn transactionMetrics(
            &self,
        ) -> Id<Foundation::NSArray<Foundation::NSURLSessionTaskTransactionMetrics>, Shared>;

        #[cfg(feature = "Foundation_NSDateInterval")]
        #[method_id(@__retain_semantics Other taskInterval)]
        pub unsafe fn taskInterval(&self) -> Id<Foundation::NSDateInterval, Shared>;

        #[method(redirectCount)]
        pub unsafe fn redirectCount(&self) -> NSUInteger;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self, Shared>;
    }
);
